"use strict";

// 시간복잡도란?
// - 알고리즘의 성능을 나타내는 척도이다.
// - 특정한 크기의 N에 대하여 알고리즘의 수행시간 분석
// - 동일한 기능을 수행하는 알고리즘이 있다면, 복잡도가 낮을수록 훨씬 유리하다.
// - 보통 N의 크기 기준으로 10의 ^8제곱을 넘으면 안 돼!
// 0 <= N <= 100

// 값이 크게 증가하는 정도 ... (코드 복잡 이런 뜻이 아니야!)

// 빅오 표기법(notation) : 가장 빠르게 증가하는 항만을 표기한 표기법이다
// 빠른 순서

// 1. O(1) : 상수시간 (constant time)
// push나 pop이나 사칙연산

// 2. O(log N) : 로그시간
// 로그는 절반씩 쪼갤 때 많이나옴
// 즉, 반복문 N번을 절반 쪼갠다 (ex) 이분탐색)
// 2의 20제곱이 100만인데 로그에 넣으면 20이 됨 확 줄어들어...!
// ❗️상수시간에 가까울 정도로 빠르다❗️

// 3. O(N) : 선형시간 (반복문 n번동안 돈다)
// - 반복문 1번!

// 4. nlogn : 반복문 2번 반 이라고 생각하면 돼!
// ex) 정렬

// 5. O(N^2) : 동적 프로그래밍 등등...

// 6. 삼차 : fluid 등

// N개의 data의 합을 출력하는 문제
let sum = 0;
let arr = [3, 5, 1, 2, 4]; // 배열

for (let i = 0; i < arr.length; i++) {
  sum += arr[i];
  // 원소의 개수가 5개니까 sum을 5번
  // 즉, 원소의 개수만큼 합계를 계산한다.
}

console.log("합 >> ", sum);

// 각 i에 모든 j를 다 곱하는 반복문
let count = 0;
for (let i = 0; i < arr.length; i++) {
  // i 한 번에
  for (let j = 0; j < arr.length; j++) {
    // j는 5번 연산이 일어난다...!
    let temp = arr[i] * arr[j];
    console.log("temp >> ", temp);
    count += 1;
  }
}

console.log("총 연산 수 >> ", count); // 25번!

// 직관적으로는 반복문 1번이 O(N)
// 2번에 O(N^2)이지만...!
// N번을 돌긴 하지만, N번을 다 안 돌 수 있고 다른 함수도 더 쓰일 수 있어서,
// 분석을 제대로 해야 한다.

// ❗️알고리즘 설계 tip❗️
// 👉 일반적으로 코딩테스트에서 시간제한은 1초에서 5초이다.
// (❗️명시되어있지 않을 경우 5초라고 생각

// ⭐️ 문제 푸는 순서 ⭐️
// ❗️시간제한을 확인한다(1초 - 5초)❗️
// 1. 시간복잡도 몇 으로 풀어야하는 지 계산하기
// 2. 문제 이해하기
// - 일단은 완전탐색으로..
// - 시간복잡도가 걸리면, 어떤 알고리즘으로 풀 지 정하기
// - hash를 써야 하는 지 검사하기(메모리를 늘리고 시간복잡도를 줄이는 방식)
