"use strict";
// 리스트를 구현하기 위한 방법
// 1. 배열 (동적배열 + 정적배열)
// 2. 연결리스트
// 👉 지금 시간에 배울 내용은 둘 중에 배열!

// 결국 우리는 리스트(순차적인 데이터 구조)를 구현하기 위해서 배열 배움!
// ❗️고정된 저장 공간❗️
// ❗️순서대로 원소 정렬❗️

// ⭐️ 배열 ⭐️
// 정의
// - 선언시에 size를 미리 정해서(고정), data를 순차적(순차)으로 저장하는 자료구조
// 🔴 즉, 고정된 공간에 순차적으로 자료들을 저장하는 자료구조 🔴

// 메모리 구조
// let arr = [1,2,3,4];
// 정수형 4개니까 연속된 16byte공간을 할당받는다.
// 그럼 주소값이 16개가 있을텐데.. 각 숫자는 4로 나눠서 나오는 첫 번째 주소값을 할당받는다.
// arr은 배열의 1byte번째에 나오는 첫 번째 주소값을 저장하고 있다.
// ❗️값에 접근을 하려면 주소값을 알고 있어야 돼❗️
// arr[1] 은 arr(배열의 첫 번째 주소값)으로 간 다음에, 4byte * 1만큼 떨어진 공간을 의미한다.
// arr[3]은 arr로 간 다음 4byte * 3만큼 떨어진 곳의 주소값으로 간다.
// 즉 저렇게 연산이 가능한 이유는 연속적으로 값이 저장 돼서 이다!!
// 그래서 값 접근은 arr[1000] => arr로 가서, arr[4 * 1000]번째 떨어진 주소값으로 간다.
// 연산 1번으로 바로바로 찾아갈 수 있어! => O(1)임

// 그럼 index란? : 배열의 이름(배열의 첫 번째 주소값)에서 몇 칸 떨어져있는지!
// 칸은 한 칸의 크기를 의미한다
// 1칸이 4byte면 [2]면 8byte만큼 떨어져있는 곳에 있는 숫자!
// [10] => 첫 번쨰 주소값에서 10칸 떨어져있다!!

{
  let arr = [1, 2, 3, 4, 5];
  let arrChange = (arr) => {
    arr[2] = 1000; // 4byte * 2만큼 떨어져있는 숫자를 1000으로 바꾸자.
    return arr;
  };

  console.log(arrChange(arr));
}

// static array의 한계!
// - 선언 이후에 더 많은 데이터가 필요할 때 공간을 늘리려면
// - 기존 5칸 배열을 그대로 살려두고 6칸짜리 배열을 또 만들어야 한다.
// -> 그럼 기존 5칸짜리 배열이 삭제되지 않기 때문에 11칸이 만들어지고,
// -> 불필요한 메모리 낭비가 이뤄진다.

// Dynamin Array
// => 선언 이후에 메모리를 늘릴 수 있다.
// 원리
// 공간이 초과되면 처음 생성한 배열보다 2배 더 큰 사이즈로 새로운 배열을 생성해서 기존 값을 옮긴다.
// 이를 더블링이라고 한다.
// ❗️그리고 기존 배열을 삭제해준다❗️ => 이게 없었다면 정적배열보다 훨씬 큰 메모리를 낭비했겠지..?

// 🔴 최종 정리 🔴
// 1. 배열은 고정, 순차, 연속
// 2. 배열의 이름은 배열의 가장 첫 번째 메모리의 주소값.
// 3. index는 배열의 이름으로 부터 공간의 크기만큼 얼마나 떨어져 있는 지!
// 4. 배열의 함수들이 어떻게 작동되는 지 알아야한다.
// 5. 4번을 바탕으로 시간복잡도를 이해하고 암기를 하고나서 써먹어야 돼!
{
  // 일단 뭐 5칸 정도만 선언
  let arr = [1, 2, 3, 4];
  arr.push(5); // 끝 삽입, 삭제는 O(1)
  arr.pop();

  arr.splice(0, 2); // index 0번 1번 삭제(접근을 먼저 하게 된다)
  // splice는 원본을 그대로 훼손한다.
  // 삭제 => 접근, 삭제, 공간 커버(이 공간 커버 때문에 O(N))
  // 끝 삭제는 공간 커버를 안 해줘도 돼!
  // O(N)
  console.log(arr);

  arr.splice(0, 1, "추가1", "추가2"); // 0번만 삭제
  // 추가 할 땐 뒤에 값을 뒤로 밀어줘서 공간을 만든다.
  // 그리고 나서 값이 추가된다.
  console.log(arr);

  arr.shift(); // index 0번 삭제
  // index 0에 접근.
  // 삭제하고
  // 공간을 커버해준다. O(N)

  arr.unshift(455); // 제일 앞으로 간다.
  // 0번부터 뒤에 값을 전부 한 칸씩 뒤로 밀어서 공간을 만든다. O(N)
  // 455를 넣는다.
  console.log(arr);

  // 1. 원하는 값 찾기 (다 하나하나 뒤집어 봐야 함 => O(N))
  let strArr = ["a", "b", "c", "d", "e", "f", "g", "h"];
  console.log(strArr.indexOf("D")); // -1이 나올 경우 끝까지 다 찾아봤다는 의미 O(N)
  // 그래서 search는 배열이란 자료구조에서 좋지가 않아. 

  // 🔴 정리 🔴
  // 삭제 : 접근(1), 삭제(1), 공간커버(M)
  // 추가 : 접근(1), 그 index부터 뒤에 있는 원소들 전부 뒤로 밀어줌(N) 추가(1)
  // ❗️끝 삭제 추가는 공간 커버, 밀려남이 없기 때문에 1이다❗️
}
