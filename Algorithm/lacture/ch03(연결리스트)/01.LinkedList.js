"use strict";
// 연결리스트
// 추가와 삭제를 배열에서 계속 구현한다면?
// 끝에서는 괜찮은데, 중간 처음에서 삭제, 추가가 된다면 시간복잡도가 O(N)으로 높아져
// 추가와 삭제가 반복되는 로직이라면 연결리스트를 사용하자.

// 정의
// 각 요소를 포인터로 연결하여 관리하는 선형 자료구조 (노드라고 부름)
// 노드 => data + pointer(다음요소를 가리킴 => 순서, 연속성 보장해줌)
// 값은 그냥 값만 갖고있다는 뜻인데 pointer의 역할이 중요하다.

// 특징
// 추가 : 메모리가 허락하는 한 계속해서 추가할 수 있다(정적배열은 아님 => 배열 공간 이외에 자료를 추가할 수 없음)
// 추가, 삭제 : O(1) ❗️ 포인터만 바꿔주면 끝나...❗️
// 접근 : 처음부터 포인터를 타고 계속 접근을 해야해서 O(N)이 걸림.
// 즉, 추가 삭제는 빠른데, 접근은 느리다.

// ⭐️ 삭제로직 O(1)
// ㅁ -> ㅁ -> ㅁ
// 2번째 요소 삭제?
// 2번째 요소의 포인터와 노드를 그대로 묶어서 없애고,
// 첫 번쨰 포인터를 3번째 포인터를 가리키게 하면 끝.
//❗️ 그냥 삭제할 이전요소의 포인터를 삭제할 요소의 포인터로 대입해주고 삭제하면 끝 ❗️

// ⭐️ 추가로직
// ㅁ -> ㅁ
// ㅁ->
// 추가할 포인터를 추가할 요소 다음 요소로 지정한다.
// 추가할 전 요소의 포인터를 추가할 요소를 가리키게 한다.

// 연결리스트 구성
// 0. 노드 : 값 + 다음 원소의 메모리 위치(pointer)
// 1. head point : head노드를 가리키는 포인터 (첫 번째 노드의 주소값을 저장하고 있음)
// 2. head node : 가장 첫 번째 노드
// 3. tail node : 가장 마지막 노드

// 연결리스트 종류
// 1. 단일 연결리스트 : 노드(값 + pointer(다음요소만))
// 2. 이중 연결리스트 : 노드(값 + pointer(이전요소) + pointer(다음요소)) => 노드가 더 뚱뚱해져서 메모리 높!
//

// 🔴 정리 🔴
// 배열은 연속적으로 저장되고 연결리스트는 임의의 위치에 저장된다.
// 배열은 random Access로, 연결리스트는 head부터 계속.. 즉, 접근은 오래걸림
// 배열의 추가 삭제는 O(N), 연결리스트는 포인터만 바꿔주면 된다. O(1)

// 칮기 : O(N)
// 추가,삭제 O(1)

// 👉 구현
// 노드 + 단일 연결리스트 class로 구성됨

// ❗️코딩테스트에서 연결리스트를 직접 구현하는 일은 많지 않음❗️
