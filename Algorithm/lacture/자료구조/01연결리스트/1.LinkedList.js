// 연결리스트

// 추가와 삭제가 반복되는 로직이라면 어떻게 해야할까? (❗️배열은 탐색용이야❗️)
// 예를들면.. todo List
// 시간표 어플이나.. 등등

// 배열의 단점을 해결하려고 연결리스트가 등장함.
// 연결리스트는 각 요소를 포인터로 연결하여 관리하는 선형 자료구조이다.

// 각 요소는 ❗️노드❗️라고 부르며, 그 안에 데이터영역(내용물)과
// 다음 요소를 가리키는 다음 요소의 주소값이 저장되어 있다.

// 추가 제거 할 때 O(1)이 소요된다.
// 대신 탐색은 O(n)이 소요된다.

// 1. 단일 연결리스트

// 2. 이중 연결리스트

// 3. 환형 연결리스트

// ❗️배열과의 차이점이 뭘까?❗️
// 1. 메모리 차이
// 배열은 각 요소가 붙어있어.(연속적)
// 연결리스트는 각 요소가 다 떨어져 있어! 제각각이야!(연속적이지 않아.)

// 2. 삭제, 추가
// 배열 : 뒷 요소들을 앞으로 당겨줘야 해..., 뒷 요소들을 한 칸 씩 미뤄야 해..
// 연결리스트
// -1) 삭제 : 삭제할 요소를 고르고 이전 요소의 포인터를 삭제할 요소의 다음요소의 주소값으로 바꿔줘.
// 그리고 나서 삭제하면 끝!
// -2) 추가 : 추가할 요소의 포인터를 추가할 요소의 다음요소 주소값으로 써주고,
// 추가 된 이전요소의 포인터를 추가 할 요소의 포인터로 바꿔줌.
// 둘 다 상수시간밖에 소요되지 않는다.

// 핵심 로직 : 찾기, 추가, 삭제!

// ⭐️ 단일 연결 리스트 (찾기 : 선형시간  추가 : 상수   삭제 : 상수 )
// 👉 찾기 (2번 요소를 찾는다.)
// headPointer => 1번요소 => 2번요소
// 1. headPointer가 가리키는 주소값이 첫 번째 값이니까 첫 번째 값으로 가서 값 확인
// 2. 아니니까 첫 번째 요소의 포인터를 통해서 2번으로 가
// 찾은 요소 나옴. => 이런식으로 단일연결리스트는 이렇게 찾음.

// 👉 추가 >>  1 2 4인데 3을 2 4사이에 추가한다면?
// 3을 추가할 때 3포인터를 4번의 주소값으로 설정
// 2는 4를 가리키고 있었지만 3의 주소값으로 포인터 부분을 바꿔준다.

// 👉 삭제 >>
// 1. 삭제할 요소의 이전 요소의 포인터값을 삭제할 다음 요소를 가리키게 함.
// 2. 삭제할 요소 삭제 끝!

// ⭐️ 이중 연결 리스트 ⭐️
// header가 있고, 각 노드들이 이전 포인터와 다음 포인터 즉, 2개를 갖는다.
// 첫 번쨰 포인터는 이전 포인터가 null이고,
// tail마지막 요소는 다음 요소 주소값이 null이다.

// << 추가 >> => 역시 O(1)만 소요됨 (연결리스트는 추가 삭제가 빨라.. 이중 연결리스트도 연결 리스트잖아!)
// 1 2 4에 3을 넣고싶다!
// 3의 다음 포인터를 4로 4의 이전 포인터를 3으로
// 2의 다음 포인터를 3으로 3의 이전 포인터를 2로..!
// 총 4단계!

// << 삭제 >>
// 2번이 4번을 가리키게 하고, 4번도 이전 2를 가리키게 하고, 3 삭제하면 끝!

// ⭐️ 환형 연결 리스트 ⭐️
// tail요소의 다음 포인터가 처음 요소를 가리키게 해서 계속 순환이 된다 => 동그랗게..!
// 즉 멀리 떨어져 있는 각각의 요소들을 원을 그리게 해 준다.

// 즉, 처음부터 하나하나 찾아야 돼서 O(n)이 걸림 => 이건 배열과 같아.
