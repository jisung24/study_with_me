"use strict";
// 자료구조에서 말 하는 배열
// - 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열되는 자료구조이다

// javascript에서의 배열
// - 자료들이 여러 type올 수 있어서 크기가 동일하지 않다.
// - 연속적이지 않을 수 있다.

// ❗️ 자바스크립트의 배열은 배열(자료구조에서 말 하는 배열)을 흉내낸 객체이다 ❗️
// 일단은 그냥 배열을 공부한다고 생각을 하자!

// 자료구조 배열의 특징 2가지
// 👉 고정된 저장 공간 => 배열을 선언 할 때 미리 크기를 고정을 해준다.
// -> js, python은 할당 할 때 배열의 크기가 동적으로 늘어나는 dynamic array이다.
// -> 배열의 이름은 배열의 첫 번째 값의 1byte의 주소값이다. (javascript도 마찬가지)

// 👉 연속적
// - ❗️random access가 가능하게 했다❗️
//
let arr = [1, 2, 3, 4];
console.log(arr[3]); // arr은 저 배열의 시작점을 뜻 한다. => 아 저 배열로 가면 되겠구나.
// 근데 [3]이라네 => 저 배열의 시작점에서 3번째 값을 찾으면 되겠구나...!
// 1바이트 만 큼 3번 떨어져있는 원소를 찾으면 돼!
// 이런 뜻이야.
// => 근데 배열은 random access가 있어서, O(1)임! -> 매우 빠름.
// 즉, 배열의 이름이나 변수의 이름은 그 값의 위치를 찾기위해서 쓰인다..!

// Random access
// 랜덤으로 접근하려면 배열의 주소값을 알아야한다.(배열의 이름으로 접근이 가능하다.)
// 배열은 ❗️연속적❗️으로 저장이 되어 있어서 어떤 index에도 즉시 접근이 가능하다.
// 즉 배열의 이름(주소값)을 알면,
// 1번째 index는 메모리 크기 * 1번쨰고,
// 10000번째 index는 메모리 크기 * 10000이다. 이런식으로 바로 접근이 가능해.
// 즉 계산을 바로 한 번만 해도 되니까 상수 시간이 바로 나오는거야!

// 하지만 연결리스트는 index라는 게 없어. 연속적이지 않아서 하나하나 다 다리를 건너줘야 돼!
// 단 연결리스트 같은 경우엔 불연속적이기 때문에, 접근하는데 O(n)이 걸린다.
// 즉, 바로 접근이 불가능하고 head부터 n까지 연산을 해줘야하기 때문이다.
// 그래서 5번째 원소에 단순 보려고 접근을 해도, 5번의 연산이 필요하다.

// static Array한계
// 데이터의 개수가 정해져있는 경우엔 static array가 좋은 방법
// 하지만, size를 모르는 배열을 선언 할 경우, 문제가 발생한다.
// 매 번 큰 size의 배열을 재선언을 하기엔 메모리를 너무 많이 차지해.
// 그래서 나온 자료구조가 dynamic Array이다.
// ⭐️ 프로그래밍 중간에 값이 더 들어와야 할 때 값 추가 이런 거 불가능! ⭐️

// ❗️Dynamic Array❗️
// size를 중간에 계속 늘릴 수 있는 배열.(size가 고정되어있지 않음.)
// 만약 크기가 10인 배열을 미리 선언을 했어.
// 11번째 값이 들어오면, size로 늘린 배열을 새로 선언하고, 그 새로운 배열에 데이터를 옮긴다.
// 그리고 기존의 배열을 삭제한다. (✨ resize라고 한다 ✨)
// 하지만 한 칸 씩 계속 배열을 새로 생성하면 비효율적이어서 기존 size에 2배 늘린 배열을 생성해준다.
// 이를 doubling이라고 한다.

// 즉, 10인 dynamic Arr생성
// 11번째 push -> doubling을 해서 resize를 해준다.
// ❗️코딩테스트 때 다이나믹 array사용이 가능하다❗️
// 결국 우리가 익혀야 할 것은 배열의 연산과 시간복잡도를 익혀야한다.
//

// 자바스크립트 배열
// 자동으로 크기가 증감되도록 설계되어 있다.(다이나믹 array)
// 연속적이라는 특징 덕분에 특정 index에 접근하는데, O(1)밖에 걸리지 않는다.

// 끝에 추가(push) : O(1)
// 끝에 삭제(pop) : O(1)
// 중간 삭제, 추가 : splice(삭제범위, 추가값); O(N)

// 배열생성 방법 4가지
// 빈 Array생성
{
  let arr = [];

  // 초기화 된 배열 생성
  let arr2 = [1, 2, 3, 4, 5];

  // 많은 값을 같은 값으로 초기화 할 경우 사용한다.
  let arr3 = Array(20).fill("I can do it!"); // 20개를 저 값으로 초기화 함.
  console.log(arr3);

  // 동적으로 1씩 늘어나는 배열 추가
  let arr4 = Array.from({ length: 30 }, (_, i) => i + 1);
  // i는 0부터임!
  console.log(arr4);
}

// 배열 값 끝 추가, 삭제, 수정, 접근 O(N)
{
  let arr = Array.from({ length: 15 }, (_, i) => i + 2);
  // 2 3 4 5 1씩 늘어나 무조건!
  console.log(arr);

  // 끝에서 추가, 삭제는 진짜 쉽고 간단함.
  arr.push(17); // O(1)
  arr.pop(); // O(1)
  arr.splice(1, 3, "dwdwdw"); // index 1번부터 3개를 삭제하고 저 dwdwdwd를 추가해줌.
  console.log(arr);
  // O(N);
}
