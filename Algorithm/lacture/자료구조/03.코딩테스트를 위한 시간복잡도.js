// 시간복잡도 시간 크기 => 작은 것 부터 오름차순
// 1. 상수시간 : O(1)
// 2. 로그시간 : O(log n)
// 3. 선형시간 : O(n)
// 4. n로그n : O(n * log n)
// 5. 제곱시간 : O(n^2)
// 제곱 이후로는 거의 안 나옴.

// 알고리즘 문제 푸는 법
// 1. 문제 이해하기
// 2. 접근 방법 (어떤 알고리즘을 써야 할 지 생각하는 단계.. 이 단계가 가장 중요함!!)
// 3. 코드 설계
// 4. 코드 구현
// 👉 우리가 알고리즘을 공부할 때 가장 중요한 건
// 문제를 보고 어떤 알고리즘 자료구조를 사용해야 하는 지 떠올리는거! ❗️

// step 1 : 문제 이해하기
// - 제약조건 보기
// ❗️ 10의 8제곱이 1초이다 ❗️
// 만약 1 <= n <= 10^5
// n제곱으로 풀면 10의 10제곱이어서 안 돼!
// 그니까 무조건 n이하인 시간복잡도로 문제를 풀어줘!! 라는거야!
// 1 <= n <= 50000은?
// 결국 10의 8제곱 1억만 안 넘으면 돼..!
// n제곱으로도 충분히 풀 수 있어..!
// 즉, 저렇게 제약조건이 작은 경우에는 그냥 시간복잡도 생각말고 답을 구해라! 라는 의미.

// 자 그럼 n이 여러 개일 때는?
// 그 n이 늘어나면 늘어날수록 문제푸는 시간에 영향을 끼치는게 있어.
// 예를들면 n이 배열의 길이.. 늘어날 수록 더 오래걸리겠지?
// 그게 n이야.
let set1 = new Set(1, 2, 3);
let set2 = new Set(3, 2, 1);
console.log(set1 === set2);
