"use strict";

// 시간 복잡도
// 빅오 표기법 (n은 입력받는 값)
// 1. 상수항은 무시 (어차피 n이 무한대로 커질수록 상수항은 필요없어짐)
// 2. 가장 큰 항 외에는 무시 O(n^2 + n)이지만 O(n^2)로 표시한다.

// 빠르기 (1부터 7까지 빠른 순)
// ❗️입력값 n이 1024번 일 때 한 번 생각해보자❗️
// ⭕️ 친 시간복잡도 이외에 보통 코딩테스트에선 사용되지 않는다.
// 1. O(1) : 상수시간
// 2(⭕️). O(log n) 로그시간 : 매 번 시간이 절반으로 줄어든다.
// 3(⭕️). O(n) : 선형시간 : 입력받은 크기만큼 반복 루프를 돌면 그게 선형시간이야.
// 4(⭕️). O(n * log n) : 선형 로그시간
// 5(⭕️). O(n^2) : 2차시간
// 6. O(2^n) : 지수시간
// 7. O(n!) : 팩토리얼 시간

// ex) 선형시간 (O(n)) :
// n = 9
// 입력받은 크기만큼 루프를 돌아 => 이게 선형시간이야.
// for (let i = 1; i <= 9; i++) {
// console.log(i);
// }
// O(2n)
// 1부터 2n까지 돌면 돼!! 똑같아 + 3, +4는 의미 없어.
// 나중에 n이 커지면 +상수값은 의미 없어져.

// ex) 로그시간 (log n)
// bst에선 원하는 값을 탐색 할 때 노드를 이동할 때 마다 시간이 절반으로 줄어든다.
// for (let i = 0; i < 10; i += 2) {
// // 계속 2배씩 이동하는 거!
// }
// ❗️선형시간과 로그시간에는 엄청난 차이가 있어... ❗️
// 1024번을 입력받을 때 선형시간은 1024번 루프 돌아야하지만,
// 로그 시간은 10번만 돌면 돼! 2의 10제곱이니까.

// O(n * log n) => 곱해졌다? 반복문 추가
// for (let i = 1; i <= 9; i++) {
// // O(n)
// for (let j = 1; i <= n; j += 2) {
//     // O(log n)
//     // 따라서 O(n * log n)
// }
// }
// O(n^2)
// for (let i = 1; i <= 9; i++) {
// // 반복문이 추가가 될 수록 *라고 생각하면 돼!
// for (let j = 1; j <= 9; j++) {}
// }

// 빅오 표기법 (❗️아래와 같이 쓰지 않음❗️)
// O(3n -30) : 보통 식에 계수가 있거나... 상수를 더하거나 빼거나.
// O(n^2 + 4000) : 이런 걸 본 적 없지..?
// ❗️상수는 어차피 n이 커지면 필요없다❗️

// ⭐️ 상수항은 무시 ⭐️
// O(n^2 + 3000)은 O(n^2)으로 표시함.

// ⭐️ 가장 큰 항 외에는 무시 ⭐️
// O(n^2 + 2n)은 O(n^2)로 표시
// +는 for문을 안에 말고 또 하나 추가해준다고 생각하자=!

// 성능 측정 방법
// 시작시간 구함
// let start = new Date().getTime();

// 끝 시간
// let end = new Date().getTime();
// console.log(end - start);
// 한 번 해보자!

// 객체 key동적으로 생성하기!!
let user = {
  name: "jiusng",
  age: 26,
};

let makeKeys = (objs, keys) => {
  let copyObjs = {
    ...objs, // 복사 할 객체!
    [keys]: "추가 됐어!!",
  };

  return copyObjs;
};
console.log(makeKeys(user, "isAdd"));
