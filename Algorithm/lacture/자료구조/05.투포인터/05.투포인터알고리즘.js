"use strict";
// ❗️ 구간 합 ❗️
// 이중 반복문을 쓸 수 있지만, n^2 시간복잡도가 소요돼서, n 선형시간으로 구하기 위해 투 포인터가 자주 쓰인다.

// 다음 배열에서 합이 10인 수열의 수는?
// 즉, 구간에서 찾을 때!
// 배열에서 어떤 구간을 찾는 알고리즘...!
// 어떤 구간이 합이 10이다. 그 구간은?

// arr = [7, 1, 3, 5, 1, 4, 2, 2, 8];
// 1. 처음에는 포인터 2개가 index 0번을 가리킨다. (이 때는 아직 구간 x)
// => 합은 7

// 2. 아직 10이 안 됐기 때문에 오른쪽 구간을 증가시킨다.
// [7, 1] 합은 8

// 3. 여전히 넘지 못 함. => 오른쪽 구간 증가시킨다.
// [7, 1, 3]
// 합은 11

// 4. ❗️ 만약 넘었다면 왼쪽 포인터 값을 오른쪽으로 증가시킨다.
// [1, 3]

// 5. 다시 안 넘었으니까 오른쪽 증가.
// [1, 3, 5]

// [1, 3, 5, 1]
// ⭐️ 10이 됐어!! ⭐️

// 이 이후에도 오른쪽을 증가시켜...! (❗️ 다음 값이 0일 수 있기 때문이다 ❗️)
// [1, 3, 5, 1, 4]

// 왼쪽 증가
// [3, 5, 1, 4]

// [5, 1, 4] ==> ⭐️ 10 됐음 ⭐️

// [5, 1, 4, 2]
// [1, 4, 2]
// [1, 4, 2, 2]
// [1, 4, 2, 2, 8]
// [4, 2, 2, 8]
// [2, 2, 8]
// [2, 8] ⭐️ 10 됐음 ⭐️
// [8] => 오른쪽의 수가 더 이상 없기 때문이다.
// 끝!

// 다음 배열에서 10이 되는 구간을 구하고 그 구간의 index를 구하자..!

let arr = [2, 7, 4, 6, 5, 3, 1];
let m = 9;
let answer = 0;
let left = 0;
let right = 0;
let sum = arr[0]; // 맞잖아.. 처음부터 시작해도 되는거 아니야..?
while (right < arr.length) {
  // 만약에 구간에.... m보다 더 큰 원소가 배열 안에 들어있다면..? => 일단은 없다고 생각을 해 볼게..!
  if (m >= sum) {
    // 구간 합 9
    if (m > sum) {
      right++; // right를 증가를 시켜줘...!
      sum += arr[right]; // 증가된 그 배열 값을 더해준다..!
      console.log(`sum의 값 >> ${sum}`);
    } else {
      // 만약 sum의 합이 같아졌다면...!
      answer++;
      console.log(`${m}이 됐어...!!`);
      console.log(`구간 >> [[[  ${left}, ${right}  ]]]`);
      right++; // 오른쪽 값 증가..!
      sum += arr[right];
    }
  } else {
    // m이 sum보다 작아......
    console.log(`현재 left >> ${left}값을 뺀다...!`);
    sum -= arr[left];
    left++; // left값을 증가시킴...
    console.log(`sum은 ${sum}으로 줄어들었어...!`);
  }
}

console.log(`정답 >> ${answer}`);
