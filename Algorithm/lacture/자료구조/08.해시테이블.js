"use strict";

// ❗️코딩테스트에서 무조건 나온다❗️
// 어떻게 사용하느냐, 어디서 사용하느냐 굉장히 중요함..!

// 1. 배열을 이용해 구현하기
// 2. 연결리스트 + 배열을 이용해 구현하기
// ❗️ 객체나 map객체를 이용해서 해시테이블을 구현한다 ❗️

// ex) 학생 정보를 관리하는 자료구조
{
  // ⭐️ 배열에 학생 정보를 담아보기 ⭐️
  //   let stu = [
  //     { name: "지성", age: 26 },
  //     { name: "김지성", age: 25 },
  //     { name: "jisung", age: 24 },
  //   ];
  // 내가 jisung를 찾기까지 o(n)이 걸림. 오래걸림....❗️

  // ❗️해시테이블에 저장하기❗️
  //   let student = {
  //     name: ["지성", "김지성"],
  //     age: [24, 25],
  //   };
  //   console.log(menu["coffee"]);
  // 즉 프로퍼티를 찾는데, O(1)이면 돼!

  // 즉, 배열에서 값을 찾아야 할 때...!
  // On이 걸리니까 hash를 사용해서 검색 시간을 O(1)로 줄인다!

  // ❗️해쉬테이블은 이미 여러 프로그래밍 언어에 내장 돼 있음❗️
  // javascript는 Object
  // python은 dictionary

  // ex) 배열에서 값을 찾기
  let students = ["지성", "종운", "홍래", "남준", "재혁", "현태"];
  // 누구를 찾으려면 최대 O(n)이 걸려...!!!

  let stu = {
    지성: true,
    종운: true,
    홍래: true,
    남준: true,
    재혁: true,
    현태: true,
  };
  console.log("현태" in stu); // key가 있는 지 검색한다.

  for (let keys in stu) {
    console.log("key >> ", keys);
  }
}

// 해쉬 함수가 더 빠른이유!!
// 해쉬 함수 때문...!!
// 1. 내가 저장하고자하는 키를 숫자로 바꾼다.
// => 이 숫자가 index가 되는거야.

// 나중에 검색을 할 때..
// 배열처럼 하나하나 다 뒤집어보는 게 아니라,
// 해쉬함수가 바로 계산해서 index를 줘.
// 그래서 시간복잡도는 O(1)이 되는거야.

// 즉, 키를 가져다가 해쉬 함수에 넣고,
// 해쉬 함수가 계산해준 숫자를 index로 삼고 그 숫자에 값을 저장하면 돼..!

// ❗️해쉬 충돌❗️
// - 해쉬 함수가 서로 다른 key에 대해서 동일한 숫자를 return 해서 줬을경우..!
// - 이럴 경우 대안이
// - 같은 숫자 index에 또 배열 형식으로 값을 2개를 같이 저장함.
// => 찾으려면 index 4에 접근해서 선형 검색(O(n)을 해야 돼)
// ---> ❗️이래서 해쉬 충돌이 일어 날 경우 언제나 검색이 O(1)은 아니다❗️

// 결론
// 수 많은 프로그래밍 언어에 이미 구현이 돼 있어..!!
// 내가 해쉬함수를 만들거나 그러지 않아도 돼
// 해쉬 함수를 통해서 빠른 배열을 만들어줌.

// 저장, 삭제, 검색의 시간복잡도는 전부 O(1)
// 해쉬 함수 덕분..!

// 즉, 결국 배열에 저장을 할 건데,
// [0]번에 key, value형식으로 저장을 함.

// 자바스크립트에선 객체가 이미 해시테이블처럼 작동 해!
