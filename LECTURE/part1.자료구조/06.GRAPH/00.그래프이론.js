"use strict";
// 배열을 어떻게 이용해야 그래프를 효율적으로 표현할 수 있는 지!

// 그래프 : 사물을 정점과 간선으로 나타내기 위한 도구
// 즉, 지역과 도로,
// 그래프를 이용해서 각각의 도시와 도로, 연결

// 구현방식
// 1) 인접 행렬 : 2차원 배열
// 2) 인접 리스트 : 연결 리스트를 이용한 방식
// 인접 리스트를 사용했을 때 쓰임세가 좀 많다.
// => 인접 행렬 방식도 종종 쓰일 때가 있다.

// 연결됐다면 1 아니면 0으로 표현함.!
// 간선에 비용이 있다면 비용을 표시한다.
// ❗️가중치가 있는 그래프❗️
{
  let graph = [
    [0, 3, 7], // 0번 노드에서 0 1 2번으로 가기위한 비용
    [3, 0, "x"], // 연결x
    [7, 0, "x"],
  ];

  // ❗️가중치가 없는 그래프❗️
  let graph2 = [
    [0, 1, 1, 0], // 0번 노드가 0번 1번 2번 3번과 연결
    [1, 0, 1, 0],
    [1, 1, 0, 1],
    [0, 0, 1, 0],
  ];
}

// DFS && BFS
// 1번부터 출발이기 때문에 그래프 0번은 []로 그냥 비워둔다.

let graph = [
  [], // 0번째는 비워둔다. => 왜냐면 거의 1번부터 시작하기 때문이다.
  // 연결이 돼 있는 정보가 다 있어!
  // 근데 격차판 길찾기는 연결이 되어 있는 지 알 수 없어..
  [2, 3, 4],
  [1],
  [1, 5, 6],
  [1, 7],
  [3, 8],
  [3],
  [4],
  [5],
];
// 서로 연결된 그래프 탐색!

// 즉, 그래프는 모든 드라마 라고 생각해
// DFS, BFS는 연관된 드라마만 보는거야! => 어떻게 보는 지가 다른거지

// 그래서 연관되지 않은 드라마는 안 돌게 됨.

// 간선 정보 => 어디와 어디가 연결이 되어있다.
// 나 처럼 1인 값을 찾기 위해서
// 좌우 상하 대각선을 본다 => 1인지 보기 위해서!

// 즉 1이네? 방문 해야겠다! => 라는 의미

// 풀이
// 처음부터 끝까지 dfs를 돈다.
// 1이 있다면 나의 상하좌우를 보고, 같은 1이 있는 지(갈 수 있는 길 인지 확인한다)
// DFS를 돌기 상하좌우를 확인을 하고, DFS를 돈다 => 연결이 되어 있는 지 확인해주는 작업!

// 우리가 표시한 그래프는 간선의 정보로 연결이 되어있다는 확인이 있었어
// 근데 격자는 없잖아. => 그래서 1일 때 연결이 되었으니 DFS를 돈다!


