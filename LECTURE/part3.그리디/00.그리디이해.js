"use strict";
// greedy algorithm
// - 현재 상황에서 가장 좋아보이는 상황만을 선택하는 알고리즘
// ❗️미래를 절대 대비하지 않고, 그냥 오늘만 살아❗️

// 🔴 👉 앞 부분에서 쉬운 문제로 출제가 자주 된다❗️ 🔴

// 예시1
// 루트에서 리프노드까지 가는 경우를 생각해보자!
// 거쳐가는 노드의 합이 가장 큰 경우는?
// ❗️각각에서 가장 큰 값을 선택하면 이론상 맞는다❗️
// 하지만 미래에 더 좋은 상황이 있었던거지... -> 그래서 그리디로는 최적의 해가 안 나올 수 있음

// ❗️즉 각각의 상황에서 가장 큰 혹은 가장 작은 값을 선택하면 돼❗️

// ❗️근데 결국 내가 현재 상황만을 보고 선택한 선택이
// 전체를 봤을 때도 최고의 선택이어야 해❗️

// 그리디가 많이 쓰이는 이유!
// 1. 그리디가 최적의 해는 안 나올 가능성이 높아!
// ❗️하지만!! 최적의 해에 가까운 값을 구할 수는 있어❗️
// ==> 그래서 근사 해를 구하는 목적으로 그리디를 사용해❗️
// 🔴 즉 100% 완벽한 해는 아니어도 근사해를 구하는 목적 🔴

// 코딩테스트에서 greedy
// 탐욕으로 최적의 해가 100% 보장되는 문제로 출시 된다
// 🔴 즉 코테에서는 최적해에 가까운 해가 아닌 최적해가 그리디로 구할 수 있게 나옴🔴
// 어떻게 보면 코테의 한계야...!

// 그리디 푸는 방법
// 0. 상황이 나뉜다.
// 1. 현재 상황에서 어떤 상황을 선택해야 할 지 생각한다.
// 2. 항상 최적의 해가 보장되는 지 확인한다.

// ==> ❗️ 최적의 선택 방법을 생각해내는게 제일 어려워...❗️
// ==> 🔴 그리고 그 방법이 최적의 해를 도출해낸다는 정당성 🔴

// 1. 거스름 돈 문제
// => 전형적인 그리디 문제
// 각각의 상황마다 선택의 옵션이 있어!
// 그 중에서 선택하면 돼!
// 500 100 50 10중 뭘 선택해야할까...?
// 500원을 최대한 많이..!

{
  // 6480원
  // 동전 [500 100 50 10]

  let total = 6480;
  let sum = 0;
  let coins = [100, 500, 50, 10];
  coins.sort((a, b) => {
    if (a > b) return -1;
    else if (a < b) return 1;
    else return 0;
  });
  // 오름차순 정렬!
  // 상황별로 반복문을 돌려줘...!
  // 각각의 상황을 선택하는거지.
  coins.forEach((value, index) => {
    let coinCnt = 0; // 각 상황별로 동전 개수가 0부터 시작해!
    if (value < total) {
      console.log(value, "won");
      coinCnt += Math.floor(total / value);
      total -= value * coinCnt;
    }
    console.log("남은 돈 >> ", total);
    console.log("동전 개수 >> ", coinCnt);
    sum += coinCnt;
  });

  console.log(`총 동전 개수 >> ${sum}`);
}

// 왜 큰 동전부터 거슬러주는 게 최적의 선택일까?
// 큰 동전이 작은 동전의 배수이기 때문이다.
// => 작은 동전으로 절대 더 적게 고를 수 없어..!

// 오늘 그리디 &&
