"use strict";
// 1. 동전 문제가 그리디인 이유
// - 동전을 매번 선택할 때, 허용하는 동전 중 가장 큰 동전을 계속 선택해서 거슬러줘야 해!
// --> 큰 동전이 작은 동전의 배수이기 때문에,
// 물론, 300원을 거슬러줘야하는데 500 100이면 100 * 3개지만
// 허용하는 한 만약 900원이면 100원짜리 9보단, 500 1개 100 4개..!
// 즉, 단계마다 허용하는 가장 큰 동전을 매 단계마다 선택한다!

let input = require("fs").readFileSync("dev/stdin").toString().split("\n");
let [N, total] = input[0].split(" ").map(Number);
let coins = [];

for (let i = 1; i <= N; i++) {
  coins.push(Number(input[i]));
}
// 초기화는 제대로 시켜준다..!

let count = 0;
for (let i = coins.length - 1; i >= 0; i--) {
  if (coins[i] <= total) {
    // 동전 개수
    // 남은 돈..!
    count += parseInt(total / coins[i]); // 해당 동전은 몇 개 사용해야하는지
    total %= coins[i]; // 남은 돈!
    console.log(`남은 돈 >> ${total}`);
    console.log(`현재 동전 개수 >> ${count}`);
  }
}
console.log(count);
//
// 해설
// 1. 각 화폐가 배수단계에 해당된다.
// 2. 각 선택마다 큰 동전을 선택하면 된다(큰 동전은 작은 동전들의 합이기 때문)
// 가치가 가장 큰 동전은 가치가 작은 동전의 합으로 항상 표현될 수 있기 때문이다.

// 1. 4790원 10개의 화폐로 거슬러보자
// => 상황별로 한 번 살펴보자!
// 50000 => 너무 커서 안 돼
// 10000 => 커서 안 돼
// 5000 => 마찬가지로 남은 돈 보다 더 커서 안 돼!
// 1000 => 4
// 500 => 1
// 100 => 2
// 50 =>
// 10
// 5
// 1
// ====> 시간복잡도 O(N)으로 풀 수 있다.
