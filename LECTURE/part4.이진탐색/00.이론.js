// => 정렬 => 버블정렬
// 자료구조 : 배열

// 검색 : ===> [5,6,78,3,1,4,6,8,9,10]; // 10
// -> 순차 검색 -> 5 6 78 3 ==> 10 => 10을 다 뒤집어 봐야 함! => N
// => O(N) : 느리지도 않고 빠르지도 않은,.... =>
// => 빠르지가 않다... =>
// 이진 탐색 => 절반씩 쪼갬
// [5,6,78,3,1,4,6,8,9,10] => 이진 탐색 불가능....!
// 9 => 1 2 3 4 5 6 7 8 9 10
// 5 < 9 => 오른쪽...

// 정렬 => NlogN ~ N^2 =>  N^2
// 정렬이 안 된 배열 => 정렬 => 이진 탐색 => N^2 (O => X)
// 정렬이 안 된 배열 => 순차탐색 => N

// 배열 => 정렬x => 순차탐색 (N)
// 배열 => 정렬o => 선형탐색 (logN)
// ===>

// 배열
// 10^9 : 10억
// 순차 탐색 : 10억번째 => 10억번째  => 10억번
// 이진 탐색 : 30 => 10개짜리 => 훨씬 빠른속도로 줄어듦 ...!
// (정렬이 되어있을 때! => ⭕️)

// 추가 : 끝에만 빠름
// 삭제 : 끝만 빠름
// 접근 : O(1) => index => 아무데나 접근이 가능

// 장점 : 탐색이 빠르다 => O(logN)
// 10억번을 순차탐색 해야 한다면, 30번으로 줄여준다.
// 👉 단, 꼭 정렬이 되어 있어야 한다.
// 👉 매우 큰 탐색 범위를 준다. => 여기서 find나 indexOf쓰면 시간복잡도 바로 out
/**
 * 이진 탐색 함수!
 * @param {*} arr : 정렬이 되어있는 배열
 * @param {*} target : 찾는 값
 * @param {*} start : 범위 시작
 * @param {*} end : 범위 끝
 * @returns : 찾으면 찾은 값의 Index || 못 찾으면 -1(indexOf와 return값이 같음)
 */
let binarySearch = (arr, target, start, end) => {
  // 값이 있을 때
  while (start <= end) {
    let mid = parseInt((start + end) / 2); // 위치를 잡아준다. => start와 end가 계속 좁아짐(바뀜)
    // Math.floor()
    // 배열의 => 7 => 3
    //
    if (arr[mid] === target) return mid;
    else if (arr[mid] < target) start = mid + 1;
    else end = mid - 1;
  }

  // 값이 없을 때!
  // while (start > end) return -1
  return -1; // while문 밖으로 벗어나는 순간 -1 return..
};

let arr = [4, 6, 8, 10, 16, 20, 99];
console.log(
  binarySearch(arr, 24, 0, arr.length - 1) === -1 ? "없습니다" : "있습니다"
);

{
  let arr = [1, 5, 3, 2, 7, 9, 10];
  console.log(arr.indexOf(2000000)); // -1
}

{
  // while
}

// 약점 : 검색
// O(1) : ==>
// 뒤에서 삭제 삽입 => O(1)

// 단점 => 검색
// => O(N) : 그냥 그런...
// => 이진 탐색을 이용해서 검색 logN(10억번 => 30번)
// => 정렬된 배열 =>

// Binary Search : 정렬된 배열 => 삽입, 삭제 느림.. => 검색에 몰빵
// 4가 추가 =>
// 추가 삭제를 느리게하고, 정렬을 엄청빠르게 함 => 올인 => 찾기에 올인 => 10억 => 30!
// 삽입, 삭제를 속도를 늦춘다... => (  )
// [1,2,3,5];
// push() : O(1) =>

// .... + Tree

// 배열 => 연결리스트

// 검색 => 연결리스트로 구현을 해보자...
// Binary Search Tree
// Tree => 연결리스트.. =>
// queue => 연결리스트 => [] => index가리키는 느낌으로 pop
