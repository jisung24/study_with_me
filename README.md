# study_with_jisung

## 2023-01-25(수)

- ### 리엑트 중 객체 state값 일부 변경에 대한 어려움 겪음.
  - `객체 문법 총 정리`
    - `객체 복사에 대한 이해`
    - `우선 복사하고싶은 객체를 spread연산자로 복사를 해 놓고 그 뒤에 추가, 수정하고 싶은 값을 적어준다.(이해 끝남.)`
    - `setObj((prev) => ({...prev, name : "변경할 값"}))` 이런식으로!!
  - `useReducer`
    - 역할 : state값을 변경하는데 사용되는 hook
    - 왜 사용되나?
      - useState를 사용해서 하면 당장 컴포넌트 안에서 밖에 쓸 수 없어.
      - 만약 이 바꾸는 로직을 여러군데에서 사용하고 싶다면, useReduce를 사용하자 => 파일 분리로도 가능.

## 2023-01-26(목)

- ### 자바스크립트에서 객체가 왜 중요할까? 왜 대다수일까?

  - 자바스크립트는 브라우져를 제어하는 언어인데, `BOM`이란 모델이 있기 때문이다.

- ### BOM이란?

  - 브라우져 전체를 의미하는 모델이라고 생각하면 편함.
  - 즉, 브라우져 전체를 javascript가 접근하고 제어할 수 있게 모델로 바꾼 것.
  - window, document, location, history, screen, navigator가 있다.
  - dom도 BOM의 일종임 => 브라우져 전체는 BOM이고, BOM안에서 document띄우는 부분이 DOM임.

- ### 브라우져 렌더링과정

## 2023-01-31

- `앞으로 readme매일매일 써야지!!`
- `testCase를 포함해서 배열로 넣는 경우 있는데, 그럴경우 shift()로 앞에 있는 testCase count빼버린다.`
- `str.indexOf("반환하고싶은 문자 => 문제같은 경우 각 알파벳의 index니까 반복하면서 모든 알파벳을 여기다가 넣어준다.")`
- `str.repeat(반복 횟수) => "A".repeat(2) === "AA"`

## 2023-02-02

- 틀린 문제 : `❗️그룹 단어 체크❗️`
  - 문제 유형 : `❗️✨이전 문자들과 비교하는 문제✨❗️`
  - 문제 결과 : `testcase답들은 전부 맞았지만 틀렸습니다. 출력`
  - 문제 접근 : 반복문 내에서 가장 첫 번째 단어를 배열에 무조건 넣어두고, 조건을 검사했다.
    - 조건1 : 이전 문자와 다른 경우(이럴 땐 문자열.indexOf가 -1이 나오면 통과!)
    - 조건2 : 이전 문자와 같은 경우(무조건 통과)
    - 통과를 한 단어는 반복문 내에서 continue를 써줬고,
      - 불통을 한 단어는 그 즉시 반복문에서 나가고, wrong++을 해줬다.
  - 답 : 옳은 것 만을 고르는 문제여서 전체 글자 수 - wrong을 해줬다. (wrong : 조건에 맞지 않은 단어의 수)

## 2023-02-04

- 푼 문제 : 중복제거, 애너그램판별, 팰린드롬, 최대수익계산

  - 어려웠던 문제 : 은근 중복제거가 어려웠는데, 대단한 아이디어를 하나 발견했다..

    ```javascript
    let uniqueNums = arr.filter((ele, idx) => {
      return arr.indexOf(ele) === idx;
      // ❗️와... 이건 진짜 생각 못 했다...❗️
    });
    ```

    - 보통 indexOf는 5가 2개 있어도 2번째 파라미터가 그대로면 무조건 앞에 원소 하나만을 return한다.
    - 그래서 filter에서 5 5면 `index는 0 1이 되지만 indexOf는 0 0 이 된다.`
    - 이후, index값과 `indexOf return값이 같은 것` 만 return 해줬더니 중복값이 제거됐다.
    - set객체만 알고있는 나에게 엄청난 무기가 됐다.`아직 한참 가야하구나.. 를 느꼈던 하루였다.`

## 2023-02-05

- 푼 문제 : 다항식 더하기, 수들의 합, 수 뒤집기 횟수

  - 수들의 합(`백준(실버 5문제 => 쉬웠음)`) : `서로 다른 자연수 n개의 합으로 숫자 s를 만든다 했을 때 n의 최댓값구하기!`

    - `최대한 많은 자연수를 활용하려면, 최대한 작은 서로 작은 자연수를 많이 써야해서 1 2 3 4 이런식으로 작은 수 부터 더해줌.`
    - `결국 200이면 190까지 밖에 안 더해진다. => 다음 수가 10보다 커서 200이 넘는데`
    - `어쩔 수 없이, 기존에 이미 더했던 10을 또 써야한다. => 그래서 개수는 반복문 i를 1부터 200을 막 념겼을 때 그 수  -1개.`

  - 수 뒤집기(`실버5`)
    - 11100011111011 => split('1')을 사용하면 0의 뭉치가 나온다!!
    - 즉 1이 몇 개가 나오든 배열안에 1이 담기지 않는다.
    - `1(뭉치)를 구분자로 배열로 만들어준다 ==> split활용가능한가 묻는 문제.`
    - 문제 이해는 10분만에 함. => 뭉치가 더 작은 걸 구하자.!
